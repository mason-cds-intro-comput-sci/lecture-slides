---
title: CDS 101 <br> Data reshaping <br> Principles of tidy data
authors: 
 - James K. Glasbrenner
 - Dominic White
---

class: center, middle, title-slide

.upper-right[
```{r logo, eval = TRUE, echo = FALSE, out.width = "605px"}
knitr::include_graphics("../../img/cds-101-online-logo.png")
```
]

.lower-right[
```{r cc-by-sa, eval = TRUE, echo = FALSE, out.width = "88px"}
knitr::include_graphics("../../img/cc-by-nc-sa.png")
```

These slides are licensed under a [Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License](http://creativecommons.org/licenses/by-nc-sa/4.0/).
]

# .font90[Data reshaping]
.title-hline[
## Principles of tidy data
]

```{r setup, include = FALSE}
# DO NOT ALTER THIS CHUNK
source("../../R/xaringan_setup.R")
library(tidyverse)
```

???

In our data wrangling journey so far we have looked at a variety of functions which take a dataframe and working with its existing rows and columns.

But sometimes we will need to reshape the dataframe. By reshaping, we usually mean converting row into columns, or columns into rows.

---

# Principles of tidy data

.footnote[
Source: Figure 12.1 in *R for Data Science* by Garrett Grolemund and Hadley Wickham.
]

.valign-slide[
```{r tidy-data-schematic, out.width = "100%", echo = FALSE}
knitr::include_graphics("../../img/tidy_data_schematic.png")
```

To be "tidy",

* one dataset should be in one dataframe
* each variable should be in its own column
* each observation (i.e. case) should be in its own row
* a cell should contain a single value
]

???

The most common reason for reshaping is to get a dataframe into what is called a "tidy" format.

You might notice that in every assignment we have been using a collection of R packages called the "tidyverse". This is because these packages all rely on the underlying assumption that the data you are using is in the tidy format.

So what do we mean by tidy? There's a few key ideas here, and should all make some intuitive sense if you think about them a little bit.

First, each dataset should be in one dataframe, and conversely a dataframe should only contain one dataset. Hopefully that seems pretty sensible. If we *don't do this, and mix up our datasets, we will need to work extra hard to make sure we are analyzing the right data each time. We might easily analyze the wrong data by mistake.

Second, each variable should be in its own column. Again, this should be pretty intuitive. If you are measuring the height of a group of people, all the heights should be in one column. You also don't want any non-height data in the height column.

Third, each observation should be in its own row. Let's imagine we measured the weight of each person as well as their height. What is an observation in this example? Is weight a separate observation to height? No. The observation in this case is a person. Height and weight are variables of that observation. So each person will have their own row, and we will have two columns for height and weight.

Finally, each cell of the table of data should contain a single value. For example, if you measured multiple weights for a person, you would not want to put all of those weight measurements in the same cell.

As I said, hopefully all of that is reasonably intuitive. Unfortunately data frequently doesn't come in a tidy format, and so we may need to do some reshaping before we can analyze.

Also we will sometimes need to convert data out of a tidy format so that we can do particular analyzes on it more easily.

---

# An example of tidy data

Consider this table of demographic information for each country:

```{r, echo=FALSE}
table1 %>%
  knitr::kable(format = "html", caption = "<span class='mono'>Demographic data</span>")
```

This dataset is tidy. Why?

???

Let's look at an example of a tidy dataset and see how it meets our four criteria.

---

# An example of tidy data

.pull-left[
```{r, echo=FALSE}
table1 %>%
  knitr::kable(format = "html", caption = "<span class='mono'>Demographic data</span>")
```
]

.pull-right[
This data is *tidy* because:

* The dataframe contains a single dataset.
* Each variable is in its own column (e.g. `year`, `population`, and `cases`).
* Each row is a separate observation.
  * You might note that a country can occur multiple times! This is because Afghanistan in 1999 (for example) is a separate observation to Afghanistan in 2000.
* Each cell is a single value.
]

???

First, this is obviously a single dataset with statistics about different countries.

We can also see that each variable about the countries has it's own column. Also, each observation is in it's own row. This might not seem obvious at first - for example, there are two rows for each country. However, we can see that there are multiple rows because we have made observations in multiple years. In this case we are treating Afghanistan in 1999 as a separate observation to Afghanistan in 2000.

All of these arrangements also mean that we meet our final criterion that each cell contains only a single value.

---

# An example of "untidy" (messy) data

Here are separate tables of the `cases` (left) and `population` (right) columns from the previous example:

.pull-left[
```{r echo = FALSE}
table4a %>%
  knitr::kable(format = "html", caption = "<span class='mono'>Cases</span>")
```
]

.pull-right[
```{r echo = FALSE}
table4b %>%
  knitr::kable(format = "html", caption = "<span class='mono'>Population</span>")
```
]

This is not tidy because:

* The dataset is split over two dataframes.
* The `cases` and `population` variables are split into two columns (by year), even though they are really each a single variable.
* The year should be a variable (as it was in the previous example), but currently only exists as a column headings.

???

Ok. You might now be wondering what untidy data looks like.

There are many ways that data can be untidy, or messy. Here's one example using exactly the same data as before.

Except that here, we've split our dataset over two dataframes. This will make our lives a little difficult if we want to do any analysis involving both cases and population.

Also, each of those variables is now in multiple columns, one column for each year. However, with the tidyverse if will often be easier to compare a variable across multiple years if all the values are in a single column.

---

# Tidy vs. messy data

.pull-left[
Why is this...
```{r, echo=FALSE}
table1 %>%
  knitr::kable(format = "html", caption = "<span class='mono'>Tidy data</span>")
```
]

.pull-right[
...better than this...

```{r echo = FALSE}
table4a %>%
  knitr::kable(format = "html", caption = "<span class='mono'>Untidy table 1</span>")
```

```{r echo = FALSE}
table4b %>%
  knitr::kable(format = "html", caption = "<span class='mono'>Untidy table 2</span>")
```
]

???

Here's a side-by-side comparison of those two formats of the same dataset.

Why is the tidy version on the left better for us?

**Next.** Because, once it is in the tidy format we can more easily use functions from the tidyverse, such as the data wrangling or data visualization functions that we have learned about.

--

.answer[
Because getting data into this form allows you to work on entire columns at a time using short and memorable commands
]

---

# Why should we care?

.valign-slide[
* Practically speaking, the tidying process makes the categories in your data more clear.

* It makes analysis much easier too, because you can easily subdivide your data by category, and apply transformations where needed.

* Provides a standardized, "best practices" way to structure and store our datasets.

  * Note that you may not collect or input your data straight into tidy format.
]

???

We usually want to keep data in a tidy format by default because that is the most intuitive format for us to understand as humans.

Thinking back to our example of country data, it is better to store the years in a column rather than having a separate column for each year, because then year is its own categorical variable in the dataset and we can easily break the dataset down by year. It is much harder to do that if different years have their own columns instead.

However, as I mentioned before, we may not always have data in a tidy format by default, so in the next few videos we will learn some functions for reshaping dataframes.

---

# The `tidyr` package

* The .mono[tidyr] package contains functions that allow you to reshape data.

* Functions are typed in a way that's very similar to the .mono[dplyr] *functions*, such as .mono[filter()] and .mono[mutate()].

* .mono[tidyr] functions:

  * .mono[pivot_longer()]: transforms wide data to narrow data (i.e. turns columns into rows).

  * .mono[pivot_wider()]: transforms narrow data to wide data (i.e. turns into rows to columns).

  * .mono[separate()]: make multiple columns out of a single column.

  * .mono[unite()]: make a single column out of multiple columns.

* .mon[tidyr] is part of the .mono[tidyverse] metapackage, and will be loaded when we import the .mono[tidyverse] in our assignments.

???

These functions are all part of the `tidyr` package. There are four functions that we will learn. The most important of these is `pivot_longer`, which reshapes columns into rows. We will see how we can use `pivot_longer` to convert the untidy dataset you just saw into the tidy version by turning the year from columns into rows.

We can do the opposite transformation with pivot_wider. This is a much less common problem to have, but its useful to know how to do.

Finally, we will learn about two functions for fixing columns which do not contain a single variable per column, `separate` and `unite`.

---

# Credits

.left-column[
License

Acknowledgments
]

.right-column[
.font80[[Creative Commons Attribution-NonCommerical-ShareAlike 4.0 International](https://creativecommons.org/licenses/by-nc-sa/4.0/)]

Content adapted from [*R for Data Science*](http://r4ds.had.co.nz) by Garrett Grolemund and Hadley Wickham, [chapter 12](http://r4ds.had.co.nz/tidy-data.html), made available under the [CC BY-NC-ND 3.0 license](http://creativecommons.org/licenses/by-nc-nd/3.0/us/).
]
